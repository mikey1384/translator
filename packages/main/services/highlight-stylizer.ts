import fs from 'fs/promises';
import path from 'path';
import { randomUUID } from 'crypto';
import log from 'electron-log';
import type { FFmpegContext } from './ffmpeg-runner.js';
import type {
  StylizedCaptionStyle,
  TranscriptHighlight,
} from '@shared-types/app';

interface WordTiming {
  start: number;
  end: number;
  word: string;
}

interface RenderStylizedHighlightOptions {
  ffmpeg: FFmpegContext;
  highlight: TranscriptHighlight;
  words: WordTiming[];
  operationId: string;
  signal?: AbortSignal;
  style?: StylizedCaptionStyle;
  progressCallback?: (update: { percent: number; stage: string }) => void;
}

const PLAY_RES_X = 1080;
const PLAY_RES_Y = 1920;

const DEFAULT_STYLE: Required<StylizedCaptionStyle> = {
  id: 'default',
  fontFamily: 'Montserrat',
  fontSize: 72,
  primaryColor: '#FFFFFF',
  highlightColor: '#FFD400',
  outlineColor: '#000000',
  backgroundColor: '#1A1A1A',
  alignment: 2,
  position: 'bottom',
};

export const DEFAULT_STYLIZED_CAPTION_STYLE: StylizedCaptionStyle = {
  ...DEFAULT_STYLE,
};

function escapeAssText(input: string): string {
  return input
    .replace(/\\/g, '\\')
    .replace(/\{/g, '\\{')
    .replace(/\}/g, '\\}')
    .replace(/\r\n|\r|\n/g, '\\N');
}

function hexToAssColor(hex: string): string {
  const normalized = hex.replace('#', '').trim();
  if (!normalized) {
    return '&H00FFFFFF';
  }
  const value = normalized.padStart(6, '0');
  const rr = value.substring(0, 2).toUpperCase();
  const gg = value.substring(2, 4).toUpperCase();
  const bb = value.substring(4, 6).toUpperCase();
  return `&H00${bb}${gg}${rr}`;
}

function toAssTimestamp(seconds: number): string {
  const clamped = Math.max(0, seconds);
  const hours = Math.floor(clamped / 3600)
    .toString()
    .padStart(1, '0');
  const minutes = Math.floor((clamped % 3600) / 60)
    .toString()
    .padStart(2, '0');
  const secs = Math.floor(clamped % 60)
    .toString()
    .padStart(2, '0');
  const centiseconds = Math.floor((clamped % 1) * 100)
    .toString()
    .padStart(2, '0');
  return `${hours}:${minutes}:${secs}.${centiseconds}`;
}

function escapeFilterFilePath(filePath: string): string {
  return filePath
    .replace(/\\/g, '\\\\')
    .replace(/:/g, '\\:')
    .replace(/,/g, '\\,')
    .replace(/'/g, "\\'")
    .replace(/\[/g, '\\[')
    .replace(/\]/g, '\\]');
}

/* eslint-disable no-useless-escape */
function buildKaraokeLine(
  words: Array<{ start: number; end: number; text: string }>,
  duration: number
): string {
  if (!words.length) {
    return escapeAssText('');
  }

  const parts: string[] = [];
  let previousEnd = 0;

  for (const word of words) {
    const gap = Math.max(0, word.start - previousEnd);
    if (gap > 0) {
      const gapCs = Math.max(1, Math.round(gap * 100));
      parts.push(`{\kf${gapCs}}\h`);
    }

    const wordDuration = Math.max(0, word.end - word.start);
    const durationCs = Math.max(1, Math.round(wordDuration * 100));
    parts.push(`{\kf${durationCs}}${escapeAssText(word.text)}`);
    previousEnd = Math.max(previousEnd, word.end);
  }

  const tail = Math.max(0, duration - previousEnd);
  if (tail > 0.01) {
    const tailCs = Math.max(1, Math.round(tail * 100));
    parts.push(`{\kf${tailCs}}\h`);
  }

  return parts.join('');
}
/* eslint-enable no-useless-escape */

function deriveStyle(
  style?: StylizedCaptionStyle
): Required<StylizedCaptionStyle> {
  return {
    ...DEFAULT_STYLE,
    ...(style ?? {}),
  };
}

function createAssScript(params: {
  style: Required<StylizedCaptionStyle>;
  dialogue: string;
  duration: number;
}): string {
  const { style, dialogue, duration } = params;
  const marginV = 120;
  const alignment = style.alignment ?? 2;

  return (
    `; Generated by highlight-stylizer\n` +
    `[Script Info]\n` +
    `ScriptType: v4.00+\n` +
    `PlayResX: ${PLAY_RES_X}\n` +
    `PlayResY: ${PLAY_RES_Y}\n` +
    `WrapStyle: 2\n` +
    `ScaledBorderAndShadow: yes\n` +
    `YCbCr Matrix: TV.709\n\n` +
    `[V4+ Styles]\n` +
    `Format: Name, Fontname, Fontsize, PrimaryColour, SecondaryColour, OutlineColour, BackColour, Bold, Italic, Underline, StrikeOut, ScaleX, ScaleY, Spacing, Angle, BorderStyle, Outline, Shadow, Alignment, MarginL, MarginR, MarginV, Encoding\n` +
    `Style: Kinetic,${style.fontFamily},${style.fontSize},${hexToAssColor(
      style.primaryColor
    )},${hexToAssColor(style.highlightColor)},${hexToAssColor(
      style.outlineColor
    )},${hexToAssColor(style.backgroundColor)},0,0,0,0,100,100,0,0,1,4,0,${alignment},80,80,${marginV},1\n\n` +
    `[Events]\n` +
    `Format: Layer, Start, End, Style, Name, MarginL, MarginR, MarginV, Effect, Text\n` +
    `Dialogue: 0,${toAssTimestamp(0)},${toAssTimestamp(
      duration
    )},Kinetic,,0,0,${marginV},,${dialogue}\n`
  );
}

function normaliseWords(
  highlight: TranscriptHighlight,
  words: WordTiming[]
): Array<{ start: number; end: number; text: string }> {
  const start = Number.isFinite(highlight.start) ? Number(highlight.start) : 0;
  const end = Number.isFinite(highlight.end) ? Number(highlight.end) : start;
  const duration = Math.max(0, end - start);

  return words
    .map(word => ({
      text: word.word ?? '',
      start: Math.max(0, (word.start ?? 0) - start),
      end: Math.max(0, (word.end ?? 0) - start),
    }))
    .filter(w => w.text && w.end > 0 && w.start < duration)
    .map(w => ({
      text: w.text,
      start: Math.max(0, Math.min(w.start, duration)),
      end: Math.max(0, Math.min(w.end, duration)),
    }))
    .sort((a, b) => a.start - b.start);
}

export async function renderStylizedHighlight(
  options: RenderStylizedHighlightOptions
): Promise<string> {
  const {
    ffmpeg,
    highlight,
    words,
    operationId,
    signal,
    style,
    progressCallback,
  } = options;

  if (!highlight?.videoPath) {
    throw new Error('Highlight is missing video path.');
  }

  const highlightStart = Number.isFinite(highlight.start)
    ? Number(highlight.start)
    : 0;
  const highlightEnd = Number.isFinite(highlight.end)
    ? Number(highlight.end)
    : highlightStart;
  const highlightDuration = Math.max(0.01, highlightEnd - highlightStart);

  const resolvedStyle = deriveStyle(style);
  const relativeWords = normaliseWords(highlight, words);

  const hasWords = relativeWords.length > 0;
  const dialogue = hasWords
    ? buildKaraokeLine(relativeWords, highlightDuration)
    : escapeAssText(highlight.title || highlight.description || '');

  progressCallback?.({
    percent: 10,
    stage: 'Preparing stylized captions',
  });

  const assContent = createAssScript({
    style: resolvedStyle,
    dialogue,
    duration: highlightDuration,
  });

  const assFilename = `stylized-${operationId}-${randomUUID()}.ass`;
  const assPath = path.join(ffmpeg.tempDir, assFilename);
  await fs.writeFile(assPath, assContent, 'utf8');

  const outputFilename = `stylized-${operationId}-${randomUUID()}.mp4`;
  const outputPath = path.join(ffmpeg.tempDir, outputFilename);

  const subtitlesFilter = `subtitles='${escapeFilterFilePath(assPath)}'`;

  const args = [
    '-y',
    '-i',
    path.resolve(highlight.videoPath),
    '-vf',
    subtitlesFilter,
    '-c:v',
    'libx264',
    '-preset',
    'veryfast',
    '-crf',
    '18',
    '-c:a',
    'copy',
    '-movflags',
    '+faststart',
    '-progress',
    'pipe:1',
    '-nostats',
    path.resolve(outputPath),
  ];

  await ffmpeg.run(args, {
    operationId: `${operationId}-stylize`,
    totalDuration: highlightDuration,
    progress: pct => {
      const bounded = Math.max(0, Math.min(100, pct));
      const scaled = 20 + bounded * 0.75;
      progressCallback?.({
        percent: Math.min(95, Math.round(scaled)),
        stage: 'Rendering stylized captions',
      });
    },
    signal,
  });

  progressCallback?.({
    percent: 100,
    stage: 'Stylized highlight ready',
  });

  try {
    await fs.unlink(assPath);
  } catch (err) {
    log.warn('[highlight-stylizer] Failed to clean up ASS file:', err);
  }

  return outputPath;
}
