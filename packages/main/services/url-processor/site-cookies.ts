import { BrowserWindow, app, session } from 'electron';
import log from 'electron-log';
import crypto from 'node:crypto';
import path from 'node:path';
import fsp from 'node:fs/promises';

type ConnectResult = {
  success: boolean;
  cookiesWritten: number;
  cancelled: boolean;
  error?: string;
};

// IMPORTANT: Do not use "cookies" here. Electron stores its own cookie DB at
// userData/Cookies (case-insensitive on macOS/Windows), so "cookies" would
// collide with that file.
const YTDLP_COOKIES_DIR = 'ytdlp-cookies';

const YOUTUBE_AUTH_COOKIE_NAMES = new Set([
  'SID',
  'HSID',
  'SSID',
  'APISID',
  'SAPISID',
  '__Secure-3PSID',
  '__Secure-3PAPISID',
  '__Secure-1PSID',
  '__Secure-1PAPISID',
]);

function hasValidYouTubeAuthCookiesInJar(
  cookies: Array<{ name?: string; expirationDate?: number }>
): boolean {
  const nowSec = Date.now() / 1000;
  return cookies.some(c => {
    const name = c.name || '';
    if (!YOUTUBE_AUTH_COOKIE_NAMES.has(name)) return false;
    // If Electron reports an expirationDate, ensure it isn't already expired.
    return !c.expirationDate || c.expirationDate > nowSec;
  });
}

// Preserve the existing YouTube cookie jar (used by older versions) so users
// don't have to "re-connect" after upgrading.
const LEGACY_YOUTUBE_PARTITION = 'persist:stage5-youtube';

function sha256Hex(input: string): string {
  return crypto.createHash('sha256').update(input).digest('hex');
}

function safeId(input: string): string {
  return sha256Hex(input).slice(0, 16);
}

function sanitizeForFilename(input: string): string {
  const lower = input.toLowerCase();
  // Keep it readable, but safe on Windows/macOS.
  return lower.replace(/[^a-z0-9._-]+/g, '_').slice(0, 60) || 'site';
}

function cookieKeyForUrl(rawUrl: string): { key: string; loadUrl: string } {
  const u = new URL(rawUrl);
  const host = u.hostname.toLowerCase();

  // Treat youtu.be + youtube.com as one cookie jar.
  if (
    host === 'youtu.be' ||
    host === 'youtube.com' ||
    host.endsWith('.youtube.com')
  ) {
    return { key: 'youtube', loadUrl: 'https://www.youtube.com/' };
  }

  return { key: host, loadUrl: u.toString() };
}

function partitionForKey(key: string): string {
  if (key === 'youtube') return LEGACY_YOUTUBE_PARTITION;
  return `persist:stage5-cookies-${safeId(key)}`;
}

export function cookiesFilePathForUrl(rawUrl: string): string {
  const { key } = cookieKeyForUrl(rawUrl);
  if (key === 'youtube') {
    return path.join(
      app.getPath('userData'),
      YTDLP_COOKIES_DIR,
      'youtube-cookies.txt'
    );
  }
  const fileName = `${sanitizeForFilename(key)}-${safeId(key)}.txt`;
  return path.join(app.getPath('userData'), YTDLP_COOKIES_DIR, fileName);
}

const exportInFlightByKey = new Map<
  string,
  Promise<{
    path: string;
    count: number;
  }>
>();

export async function exportCookiesToFileForUrl(rawUrl: string): Promise<{
  path: string;
  count: number;
}> {
  const { key } = cookieKeyForUrl(rawUrl);
  const existing = exportInFlightByKey.get(key);
  if (existing) return existing;

  const promise = (async () => {
    const partition = partitionForKey(key);
    const cookiePath = cookiesFilePathForUrl(rawUrl);

    await fsp.mkdir(path.dirname(cookiePath), { recursive: true });

    const s = session.fromPartition(partition);
    const cookies = await s.cookies.get({});

    if (cookies.length === 0) {
      await fsp.unlink(cookiePath).catch(() => {});
      return { path: cookiePath, count: 0 };
    }

    // Netscape cookie file format expected by yt-dlp.
    const lines: string[] = [
      '# Netscape HTTP Cookie File',
      '# This file was generated by Translator for yt-dlp. Do not edit.',
      '',
    ];

    for (const c of cookies) {
      const domain = c.domain || '';
      const includeSubdomains = domain.startsWith('.') ? 'TRUE' : 'FALSE';
      const cookiePathField = c.path || '/';
      const secure = c.secure ? 'TRUE' : 'FALSE';
      const expires = c.expirationDate ? Math.trunc(c.expirationDate) : 0; // 0 = session cookie
      const name = c.name || '';
      const value = c.value || '';

      // Tools like yt-dlp support marking HttpOnly cookies by prefixing the domain.
      const domainField = c.httpOnly ? `#HttpOnly_${domain}` : domain;
      lines.push(
        [
          domainField,
          includeSubdomains,
          cookiePathField,
          secure,
          String(expires),
          name,
          value,
        ].join('\t')
      );
    }

    await fsp.writeFile(cookiePath, lines.join('\n'), {
      encoding: 'utf8',
      mode: 0o600,
    });
    if (process.platform !== 'win32') {
      await fsp.chmod(cookiePath, 0o600).catch(() => {});
    }

    log.info(
      `[site-cookies] Exported ${cookies.length} cookie(s) for key=${key} to ${cookiePath}`
    );
    return { path: cookiePath, count: cookies.length };
  })().finally(() => {
    exportInFlightByKey.delete(key);
  });

  exportInFlightByKey.set(key, promise);
  return promise;
}

export async function clearCookiesForUrl(rawUrl: string): Promise<void> {
  const { key } = cookieKeyForUrl(rawUrl);
  const partition = partitionForKey(key);
  const cookiePath = cookiesFilePathForUrl(rawUrl);

  try {
    const s = session.fromPartition(partition);
    await s.clearStorageData({
      storages: ['cookies', 'localstorage', 'indexdb', 'serviceworkers'],
    });
  } catch (err) {
    log.warn('[site-cookies] Failed to clear session storage:', err);
  }

  await fsp.unlink(cookiePath).catch(() => {});
}

export async function getCookieStatusForUrl(rawUrl: string): Promise<{
  count: number;
  hasYouTubeAuth: boolean;
}> {
  const { key } = cookieKeyForUrl(rawUrl);
  const partition = partitionForKey(key);

  try {
    const s = session.fromPartition(partition);
    const cookies = await s.cookies.get({});
    return {
      count: cookies.length,
      hasYouTubeAuth:
        key === 'youtube' && hasValidYouTubeAuthCookiesInJar(cookies),
    };
  } catch {
    return { count: 0, hasYouTubeAuth: false };
  }
}

const connectInFlightByKey = new Map<string, Promise<ConnectResult>>();
const connectWinByKey = new Map<string, BrowserWindow>();

export async function connectCookiesInteractive(
  rawUrl: string
): Promise<ConnectResult> {
  const { key, loadUrl } = cookieKeyForUrl(rawUrl);

  const existing = connectInFlightByKey.get(key);
  if (existing) {
    try {
      const win = connectWinByKey.get(key);
      win?.show();
      win?.focus();
    } catch {
      // ignore
    }
    return existing;
  }

  const partition = partitionForKey(key);

  const promise: Promise<ConnectResult> = new Promise(resolve => {
    const win = new BrowserWindow({
      width: 1100,
      height: 850,
      // Avoid modal/parent windows for auth flows. On some platforms, modal
      // sheets can feel "uncloseable" to users.
      title: 'Connect (close this window when done)',
      autoHideMenuBar: true,
      webPreferences: {
        nodeIntegration: false,
        contextIsolation: true,
        webSecurity: true,
        partition,
      },
    });
    connectWinByKey.set(key, win);

    // Remove "Electron/x" from UA to reduce embedded-browser detection.
    try {
      const ua = win.webContents.getUserAgent();
      const sanitized = ua
        .replace(/\sElectron\/[0-9.]+/g, '')
        .replace(/\s{2,}/g, ' ')
        .trim();
      win.webContents.setUserAgent(sanitized);
    } catch {
      // ignore
    }

    win.loadURL(loadUrl).catch(err => {
      log.error('[site-cookies] Failed to load connect URL:', err);
    });

    // Some pages register beforeunload handlers that can prevent closing.
    // We want users to be able to close the connect window reliably.
    win.webContents.on('will-prevent-unload', event => {
      event.preventDefault();
    });

    // Provide a keyboard close path even if the window chrome is confusing.
    win.webContents.on('before-input-event', (event, input) => {
      const key = (input.key || '').toLowerCase();
      const wantsClose = key === 'w' && (input.control || input.meta);
      if (wantsClose) {
        event.preventDefault();
        try {
          win.close();
        } catch {
          // ignore
        }
      }
    });

    const cleanup = () => {
      connectWinByKey.delete(key);
      connectInFlightByKey.delete(key);
    };

    const finish = async (error?: string) => {
      try {
        const exported = await exportCookiesToFileForUrl(rawUrl);
        const success = exported.count > 0;
        resolve({
          success,
          cookiesWritten: exported.count,
          // Treat "no cookies" as a cancellation (user closed without completing the flow).
          cancelled: !success,
          error: error || (success ? undefined : 'No cookies were captured.'),
        });
      } catch (err: any) {
        resolve({
          success: false,
          cookiesWritten: 0,
          cancelled: false,
          error: error || err?.message || String(err),
        });
      } finally {
        cleanup();
      }
    };

    win.on('closed', () => {
      // Treat close as completion; user can just close the window once they're done.
      finish().catch(() => {});
    });

    win.webContents.on('did-fail-load', (_evt, code, desc) => {
      log.warn(`[site-cookies] Connect window did-fail-load: ${code} ${desc}`);
    });
  });

  connectInFlightByKey.set(key, promise);
  return promise;
}
