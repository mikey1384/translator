import { BrowserWindow, app, session } from 'electron';
import log from 'electron-log';
import path from 'node:path';
import fsp from 'node:fs/promises';
import { getFocusedOrMainWindow } from '../../utils/window.js';

const YOUTUBE_PARTITION = 'persist:stage5-youtube';

function isRelevantCookieDomain(domain: string): boolean {
  const d = domain.startsWith('.') ? domain.slice(1) : domain;
  return (
    d.endsWith('youtube.com') ||
    d.endsWith('youtu.be') ||
    d.endsWith('google.com') ||
    d.endsWith('googleusercontent.com')
  );
}

function looksLikeAuthCookie(name: string): boolean {
  // Heuristic: auth cookies that often indicate a signed-in Google session.
  // We still export all cookies; this is only used to report "connected" status.
  return (
    name === 'SID' ||
    name === 'HSID' ||
    name === 'SSID' ||
    name === 'APISID' ||
    name === 'SAPISID' ||
    name === '__Secure-3PSID' ||
    name === '__Secure-3PAPISID' ||
    name === '__Secure-1PSID' ||
    name === '__Secure-1PAPISID'
  );
}

export function getYouTubeCookiesFilePath(): string {
  return path.join(app.getPath('userData'), 'cookies', 'youtube-cookies.txt');
}

let exportInFlight: Promise<{
  path: string;
  count: number;
  hasAuthCookies: boolean;
}> | null = null;

export async function exportYouTubeCookiesToFile(): Promise<{
  path: string;
  count: number;
  hasAuthCookies: boolean;
}> {
  if (exportInFlight) return exportInFlight;

  exportInFlight = (async () => {
    const cookiePath = getYouTubeCookiesFilePath();
    await fsp.mkdir(path.dirname(cookiePath), { recursive: true });

    const s = session.fromPartition(YOUTUBE_PARTITION);
    const all = await s.cookies.get({});
    const cookies = all.filter(c => isRelevantCookieDomain(c.domain));

    let hasAuthCookies = false;
    for (const c of cookies) {
      if (looksLikeAuthCookie(c.name)) {
        hasAuthCookies = true;
        break;
      }
    }

    // Netscape cookie file format expected by yt-dlp.
    const lines: string[] = [
      '# Netscape HTTP Cookie File',
      '# This file was generated by Translator for yt-dlp. Do not edit.',
      '',
    ];

    for (const c of cookies) {
      const domain = c.domain || '';
      const includeSubdomains = domain.startsWith('.') ? 'TRUE' : 'FALSE';
      const cookiePathField = c.path || '/';
      const secure = c.secure ? 'TRUE' : 'FALSE';
      const expires = c.expirationDate
        ? Math.trunc(c.expirationDate)
        : 0; // 0 = session cookie
      const name = c.name || '';
      const value = c.value || '';

      // yt-dlp (and many tools) support marking HttpOnly cookies by prefixing the domain.
      const domainField = c.httpOnly ? `#HttpOnly_${domain}` : domain;
      lines.push(
        [
          domainField,
          includeSubdomains,
          cookiePathField,
          secure,
          String(expires),
          name,
          value,
        ].join('\t')
      );
    }

    await fsp.writeFile(cookiePath, lines.join('\n'), {
      encoding: 'utf8',
      mode: 0o600,
    });
    // Best-effort tighten permissions on POSIX.
    if (process.platform !== 'win32') {
      await fsp.chmod(cookiePath, 0o600).catch(() => {});
    }

    log.info(
      `[youtube-cookies] Exported ${cookies.length} cookies (auth=${hasAuthCookies}) to ${cookiePath}`
    );

    return { path: cookiePath, count: cookies.length, hasAuthCookies };
  })().finally(() => {
    exportInFlight = null;
  });

  return exportInFlight;
}

export async function clearYouTubeCookies(): Promise<void> {
  try {
    const s = session.fromPartition(YOUTUBE_PARTITION);
    await s.clearStorageData({
      storages: ['cookies', 'localstorage', 'indexdb', 'serviceworkers'],
    });
  } catch (err) {
    log.warn('[youtube-cookies] Failed to clear session storage:', err);
  }

  const p = getYouTubeCookiesFilePath();
  await fsp.unlink(p).catch(() => {});
}

let connectWin: BrowserWindow | null = null;
let connectInFlight:
  | Promise<{
      success: boolean;
      cookiesWritten: number;
      hasAuthCookies: boolean;
      cancelled: boolean;
      error?: string;
    }>
  | null = null;

export async function connectYouTubeCookiesInteractive(): Promise<{
  success: boolean;
  cookiesWritten: number;
  hasAuthCookies: boolean;
  cancelled: boolean;
  error?: string;
}> {
  if (connectInFlight) {
    try {
      connectWin?.show();
      connectWin?.focus();
    } catch {
      // ignore
    }
    return connectInFlight;
  }

  connectInFlight = new Promise(resolve => {
    const parent = getFocusedOrMainWindow() ?? undefined;
    const win = new BrowserWindow({
      width: 1100,
      height: 850,
      parent,
      modal: Boolean(parent),
      title: 'Connect YouTube',
      webPreferences: {
        nodeIntegration: false,
        contextIsolation: true,
        webSecurity: true,
        partition: YOUTUBE_PARTITION,
      },
    });
    connectWin = win;

    // Remove "Electron/xx" from UA to reduce the chance of Google treating this as an embedded browser.
    try {
      const ua = win.webContents.getUserAgent();
      const sanitized = ua.replace(/\sElectron\/[0-9.]+/g, '').replace(/\s{2,}/g, ' ').trim();
      win.webContents.setUserAgent(sanitized);
    } catch {
      // ignore
    }

    win.loadURL('https://www.youtube.com/').catch(err => {
      log.error('[youtube-cookies] Failed to load YouTube in connect window:', err);
    });

    const finish = async (cancelled: boolean, error?: string) => {
      try {
        const exported = await exportYouTubeCookiesToFile();
        const success = exported.count > 0;
        resolve({
          success,
          cookiesWritten: exported.count,
          hasAuthCookies: exported.hasAuthCookies,
          cancelled,
          error: error || (success ? undefined : 'No YouTube cookies were captured.'),
        });
      } catch (err: any) {
        resolve({
          success: false,
          cookiesWritten: 0,
          hasAuthCookies: false,
          cancelled,
          error: error || err?.message || String(err),
        });
      }
    };

    win.on('closed', () => {
      connectWin = null;
      connectInFlight = null;
      // Treat close as completion; user can just close the window once they're done.
      finish(false).catch(() => {});
    });

    win.webContents.on('did-fail-load', (_evt, code, desc) => {
      log.warn(`[youtube-cookies] Connect window did-fail-load: ${code} ${desc}`);
    });

    // If the user closes quickly we still export whatever exists.
    // Renderer can decide whether to retry downloads.
  });

  return connectInFlight;
}
